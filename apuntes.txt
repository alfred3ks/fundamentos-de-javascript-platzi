FUNDAMENTOS DE JAVASCRIPT:
____________
1.VARIABLES:
------------
var nombre; // Declaracion de una variable
console.log(nombre); // undefined

nombre = 'Alfredo'; // Asignacion de la variable
console.log(nombre);

var apellido = 'Sánchez';

NOTA: Usaremos comillas simples para los string (''),
tambien LA ; al final de sentencia puede ser opcional, yo en mi caso lo voy a poner.

console.log('Hola, ' + nombre + '.'); //Usando el operador concatenacion (+)

console.log(`Hola, ${nombre}.`); // Usando comillas invertidas. O llamadas backticks.

console.log(`Hola, ${nombre} ${apellido}.`)

JS es debilmente tipado y tenemos que tener cuidado con eso.

Ejemplo:

    var edad = 45;
    edad = '45 años'
    console.log(`Tengo ${edad} años`)

La variable edad primero comenzo siendo un numero pero luego se le asigno un string y JS no se que queja nada.

___________________
2.VARIABLES STRING:
-------------------
Los strings son cadenas de texto. Para indicar que estamos usando una cadena de texto debemos de colocar las comillas simples o dobles.

En este curso utilizaremos los métodos:

    toUpperCase, que sirve para transformar un String a mayúsculas.

    toLowerCase, que sirve para transformar el string a minúsculas.

También usaremos el atributo:

    length, que nos indica la cantidad de caractéres que tiene un string.

Para concatenar dos strings se utiliza el símbolo (+)
var nombreCompleto = nombre + ’ ’ + apellido

Desafío: Encuentra la última letra de tu nombre

Variables string, metodos y atributos mas usados.
OJO los metodos los invocamos .metodo(),
y los atributos no llevan parentesis. .atributo

    var nombre = 'Alfredo';
    var apellido = 'Sánchez';

Vamos a convertir el nombre todo en mayusculas. Usando el metodo .toUpperCase()

    var nombreEnMayuscula = nombre.toUpperCase();
    console.log(nombreEnMayuscula);

Vamos a transformar el apellido en minusculas, usaremos el metodo .toLowerCase()

    var apellidoEnMinusculas = apellido.toLowerCase();
    console.log(apellidoEnMinusculas)

Conocer un caracter de una string, usaremos el metodo .charAt() que recibe la posicion del caracter que queremos conocer. Si no le decimos ningun parametro nos arroja la primera letra

    var primeraLetraNombre = nombre.charAt();
    var primeraLetraNombre = nombre.charAt(5);
    var primeraLetraNombre = nombre.charAt(3);
    console.log(primeraLetraNombre);

Tambien podemos preguntar cuantos caracteres tiene. Usaremos el atributo .length

    var cantidadDeLetrasNombre = nombre.length;
    console.log(cantidadDeLetrasNombre);

Tambien podemos ver como concatenar dos string.

    var nombreCompleto = nombre + ' ' + apellido;
    console.log(nombreCompleto);

Tenemos otra forma de concatenar usando template string, usando las comillas doble invertidas (``), interpolacion de texto. Es mas moderno a partir de ES6

    var nombreCompletoString = `${nombre} ${apellido}.`;
    console.log(nombreCompletoString);

Podemos tambien a un substring dentro de un string, lo haremos con el metodo substring() el cual recibe dos parametros, desde donde queremos que empiece, osea que posicion y cuantos caracteres queremos que tome.

    var str = nombre.substr(1, 4);
    console.log(str);

Desafio mostrar la ultima letra de tu nombre:

Obtengo todos los caracteres del nombre, usando el metodo .split()

    var todosLosCaracteres = nombre.split('');
    console.log(todosLosCaracteres); // Muestro todos los caracteres.

Obtengo la ultima letra del nombre:

    var ultimaLetra = todosLosCaracteres[todosLosCaracteres.length -1];
    console.log(ultimaLetra);


Otra forma mas sencilla:

    var ultimaLetraNombre = nombre.charAt(nombre.length -1);
    console.log(ultimaLetraNombre);

____________________
3.VARIABLES NUMEROS:
--------------------
En esta seccion aprenderemos variables de tipo números y las operaciones más comunes en este tipo de variables.

En esta clase veremos operadores matemáticos como:

    suma ( + )
    resta ( - )
    multiplicación (*)
    división (/)

Recuerda que en operaciones con decimales debemos realizar operaciones adicionales para conseguir un resultado preciso. Ej. var total = ( precioDeVino * 100 * 3) / 100

Para redondear una operación se utiliza la función: Math.round


Números en JS y las operaciones mas comunes.
Supongamos que tenemos una variable que tiene un numero

    var edad = 27;
    console.log(edad);

Incrementos de una variable:

    edad = edad + 1; esto es lo mismo que abajo

    edad += 1;
    console.log(edad);

Decremento de una variable:

    var peso = 75;
    console.log(peso)
    // peso = peso -2;
    peso -= 2;
    console.log(peso)

Sumar dos numeros distintos:

    var sandwich = 1;
    peso  += sandwich; // Nos comemos un sandwich
    console.log(`El peso despues de comerme un sandwich es ${peso} Kg.`);

Restar dos numeros:

    var jugarAlFutbol = 3;
    peso -= jugarAlFutbol;
    console.log(`Despues de jugar al futbol mi peso es de ${peso} Kg`)

Ejemplo con decimales:

    var precioVino = 200.3;
    var total = precioVino * 3;
    console.log(total);

Si imprimimos asi lo hace con muchos decimales y no es tan exacto imaginate que es el resultado de una carrito.

Para que sea preciso usaremos a el modulo de JS matematicas Math:

    total = Math.round(precioVino * 3 * 100) / 100;
    console.log(total);

Si queremos dar mas de un decimal, con el metodo .toFixed() y le decimos la cantidad de decimales, pero ojo el valor que nos arroja es un string, OJO con eso:

    var totalStr = total.toFixed(2);
    console.log(totalStr);

Para pasar ese string a numero, con el metodo parseFloat() y le pasamos el dato como parametro:

    var totalStrNumero = parseFloat(totalStr);
    console.log(totalStrNumero);

Ahora vamos a ver como hacer una division:

    var pizza = 8; // tenemos una pizza en 8 porciones
    var personas = 2;
    var cantidadPorcionesPersona = pizza / personas;

    console.log(cantidadPorcionesPersona);

____________
4.FUNCIONES:
------------
Las funciones son fracciones de código reutilizable. En esta clase aprenderemos a definir e invocar nuestras funciones. Para definir una función utilizaremos la palabra reservada ““function””.

Delimitamos el cuerpo de la función usando llaves { }. Los parámetros de la función son variables que se pasan a la función escribíendolos entre paréntesis ()

Definir funciones nos sirve para reutilizar código. JavaScript es un lenguaje interpretado, esto quiere decir que intentará ejecutar el código sin importar si los parámetros que le pasemos a la función estén invertidos o incluso incompletos.


    var nombre = 'Alfredo';
    var edad = 45;

Para definir una funcion se usa la palabra reservada function, luego el nombre que llevara la funcion. Esta puede recibir o no parametros, pero lo veremos mas adelante, para este caso no. Para llamar la funcion escribimos el nombre la funcion con los parentesis.

    function imprimirEdad(){
        console.log(`${nombre} tiene ${edad} años.`);
    }

    imprimirEdad();

Funcion pasando parametros, para diferentes personas. Aqui vemos el potencial de las funciones.

    function imprimirEdadParametros(n, e){
        console.log(`${n} tiene ${e} años.`)
    }

    imprimirEdadParametros('Vicky', 29);
    imprimirEdadParametros('Andres', 49);
    imprimirEdadParametros('Diego', 36);

Pasamos por parametros las variables arriba declaradas:

    imprimirEdadParametros(nombre, edad);

Ahora una cosa interesante veamos que pasa si invertimos los parametros. JS no lanza ningun error, lo ejecuta sin problemas. Hay que tener cuidado con esto, igual pasa si no le pasamos parametros.

    imprimirEdadParametros(34, 'Andrea');
    imprimirEdadParametros();

___________________________
5.ALCANCE DE LAS FUNCIONES:
---------------------------
En esta clase hablaremos del alcance que tienen las funciones. Si una variable no está definida dentro del cuerpo de una función hablamos de una variable global. Por el contrario, una variable definida dentro de una función es una variable local.

Para que la ejecución de una función no modifique una variable global usamos parámetros en lugar de pasar directamente la variable.

Es posible utilizar el mismo nombre para una variable global y para el parámetro de una función con un alcance local.


    var nombre = 'Alfred';
    var apellido = 'Sanchez';

    function imprimirNombreMay(){
        nombre = nombre.toUpperCase();
        console.log(nombre);
    }

    imprimirNombreMay();

Si una variable no esta definida dentro del cuerpo de una funcion se dice que esa variable es de alcence global. Eso significa que se puede acceder desde cualquier funcion.

Cuando definimos una variable como es nuestro ejemplo de manera global esta se le asigna al objeto global y este objeto global depende donde estemos ejecutando js. Si es en un servidor seria el entorno de NODE, y si es en el cliente el objeto global seria windows, la ventana.

    console.log(window.nombre);

Es ahi donde esta definido esta variable.

Ahora una cosa que hay que ver que nuestra funcion al acceder a nuestra variable esta sucediendo un "efecto de lado" esto quiere decir que esta funcion va a modificar variables que no estan definidas dentro de ella, va a tocar cosas que entre comillas no le corresponden, lo cual es muy recomendable evitar dentro de nuestro codigo.

Veamos como podemos hacer para hacer nuestro codigo mas profesional y no modificar nuestra variable global.

    function imprimirNombreMayProf(n){
        n = n.toUpperCase();
        console.log(n);
    }

    imprimirNombreMayProf(apellido);

Asi evitamos el efecto de lado y nuestra variable global no es modificada. La varible n dentro de la funcion local y solo se puede acceder a ella dentro de la funcion en el alcance global no existe.

    console.log(n);

    app.js:37 Uncaught ReferenceError: n is not defined
    at app.js:35


Una cosa que tambien nos permite JS que el parametros que le pasemos a nuestra funcion la podemos llamar igual que la varible global asi que nuestrs varible existe dentro de la funcion y fuera de esta asi:



    function imprimirNombreMayProf(nombre){
        nombre = nombre.toUpperCase();
        console.log(nombre);
    }

__________
6.OBJETOS:
----------
Vamos a empezar a trabajar con objetos, veremos cómo declararlos, cuáles son sus ventajas, cómo asignarles atributos y cómo trabajar con ellos dentro de las funciones.

Los objetos se definen delimitados mediante llaves {}

Un atributo se compone de una clave (key) y un valor (value), que se separan entre sí por dos puntos “”:"". Los valores pueden ser de tipo string, número, booleano, etc. Cada atributo está separado del siguiente por una coma. Un objeto puede tener todos los atributos que sean necesarios.

Escribir el nombre de un objeto separado por un punto del nombre de un atributo, nos permite acceder al valor de dicho atributo para ese objeto. Un objeto también se puede pasar como atributo en una función.

Las últimas versiones de JavaScript nos permiten desglosar el objeto para acceder únicamente al atributo que nos interesa. Esto se consigue encerrando el nombre del atributo entre llaves { }.


    var nombreAlfred = 'Alfred';
    var nombreDario = 'Dario';

Lo mejor es crear un objeto, donde tenemos una clave con un valor.

Onjetos de personas:

    var alfred = {
        nombre: 'Alfred',
        apellido: 'Sánchez',
        edad: 45
    }

    var dario = {
        nombre: 'Dario',
        apellido: 'Susnisky',
        edad: 27
    }

    function imprimirNombreMay(persona){
        var nombre = persona.nombre.toUpperCase();
        console.log(nombre);
    }

Para acceder a los elementos del objejo lo hacemos invocando el objeto.propiedad como en este caso alfred.nombre


    imprimirNombreMay(alfred);
    imprimirNombreMay(dario);

Ahora si solo necesitamos pasar de nuestro objeto el nombre lo podemos hacer asi:

Se llama desestructurar el objeto:

    function imprimirSoloNombre({ nombre }){
        // Por parametro recibe el objeto que queramos
        var nombre = nombre.toUpperCase();
        console.log(`Desestructuramos el objeto: ${nombre}.`);
    }

    imprimirSoloNombre(alfred);

Tambien podemos definir el objeto aqui:

    imprimirSoloNombre({ nombre:'Pepito' })

_________________________
7.DESESTRUCTURAR OBJETOS:
-------------------------
En esta clase aprenderemos otra forma de acceder a los atributos de los objetos que es la desestructurización de los mismos.
Para no duplicar las variables introducir el nombre de la variable como parámetro de la segunda variable. Ej var{nombre} = persona

Reto: resolver la función que está comentada al final del ejercicio.


Creamos nuestros objetos.

    var alfred = {
        nombre: 'Alfred',
        apellido: 'Sánchez',
        edad: 45
    }

    var chris = {
        nombre: 'Christian',
        apellido: 'Sánchez',
        edad: 10
    }

    function imprimeNombreEnMay(persona){
        // var nombre = persona.nombre --> Lo mismo que abajo
        var { nombre } = persona;
        console.log(nombre.toUpperCase());
    }

    imprimeNombreEnMay(alfred);
    imprimeNombreEnMay(chris);

Reto crear una funcion que imprima el nombre y la edad, y que diga: Hola, me llamo xxx y tengo xx años.

    function imprimirReto(persona){
        // Aqui desestructuramos el objeto
        var { nombre, edad } = persona;
        console.log(`Hola, me llamo ${nombre} y tengo ${edad} años.`)
    }

    imprimirReto(alfred);
    imprimirReto(chris);

___________________________________
8.PASAR PARAMETROS COMO REFERENCIA:
-----------------------------------
Javascript se comporta de manera distinta cuando le pasamos un objeto como parámetro.

Cuando los objetos se pasan como una referencia, estos se modifican fuera de la función. Para solucionar esto se puede crear un objeto diferente. Esto lo podemos hacer colocando tres puntos antes del nombre. Ej …persona.


Creamos nuestros objetos.

    var alfred = {
        nombre: '',
        apellido: 'Sánchez',
        edad: 45
    }

    var chris = {
        nombre: 'Christian',
        apellido: 'Sánchez',
        edad: 10
    }

    function imprimeNombreEnMay(persona){
        // var nombre = persona.nombre --> Lo mismo que abajo
        var { nombre } = persona;
        console.log(nombre.toUpperCase());
    }

    imprimeNombreEnMay(alfred);
    imprimeNombreEnMay(chris);

Veamos el tema de pasar parametros

    function cumpleanos(persona){
        var persona = persona.edad +=1;
        console.log(persona);

    }

    console.log(alfred);

    cumpleanos(alfred);

    console.log(alfred);

    cumpleanos(alfred);
    cumpleanos(alfred);
    cumpleanos(alfred);

    console.log(alfred);


Como podemos ver JS tiene un tipo de comportamiento distinto con los objetos, que al sumar la edad esta se modifica en el objeto inicila y si volvemos a incrementar la edad esta siempre se modificaria en el objeto, esto no nos conviene, queremos que el objeto original no se modifique.

    LOS OBJETOS QUE PASAMOS POR PARAMETROS SE PASAN POR "REFERENCIA", eso quiere decir que si lo modificamos dentro del cuerpo de una funcion su valor se va a ver modificado fuera de esa funcion.

Ahora como ¿podemos evitar esto? bueno una es dejarlo como esta sabiendo lo que sucede que nuestro objeto inicial seria modificado porque es algo que realmente queremos, o tambien podemos devolver un nuevo objeto y este nuevo objeto debe tener todo lo mismo del objeto original excepto la edad que se debe incrementar, asi no modificamos el objeto original.

    var susan = {
        nombre: 'Susana',
        apellido: 'Serrano',
        edad: 45
    }

    var leonard = {
        nombre: 'Leonardo',
        apellido: 'Turtle',
        edad: 15
    }

    function cumpleanoGood(persona){
        // Desglosamos a la persona dentro de este nuevo objeto
        return {
            ...persona,
            edad: persona.edad + 1
        }
        console.log(persona)
    }

Objeto original
    console.log(susan);

Objeto al sumar en 1 la edad
    var susanTwoObj= cumpleanoGood(susan);
    console.log(susanTwoObj);

Vemos que no se altera el objeto original
    console.log(susan);

Ahora vemos el ejemplo con tortle

    function cumpleanos(persona){
        return {
            ...persona,
            edad: persona.edad + 1
        }
    }

    var newLeonard = cumpleanos(leonard);

    console.log(leonard);
    console.log(newLeonard);
    console.log(leonard);

______________________________
9.COMPARACIONES EN JAVASCRIPT:
------------------------------
Existen varias maneras de comparar variables u objetos dentro de javascript. En el primer ejemplo le asignamos a X un valor numérico y a Y un string. Para poder compararlos debemos agregar dos signos de igual (==). Esto los convierte al mismo tipo de valor y permite que se puedan comparar.

Cuando realizamos operaciones es recomendable usar tres símbolos de igual (===). Esto permite que JavasScript no iguale las variables que son de distinto tipo. Te recomendamos que uses el triple igual siempre que estés comparando variables.

Existen cinco tipos de datos que son primitivos:

    Boolean
    Null
    Undefined
    Number
    String
    */

    var x = 4;
    var y = '4';

Primera forma de comparar cosas en JS, para eso usaremos el ==, doble igual.

    console.log(x == y); // true

Cuando usamos doble igual (==)en JS lo que hace el lenguaje es comparar ambas variables en el tipo de la variable, agarra el valor de x = 4 numerico y lo tranasforma a string y lo compara con la variable y = '4' que es otro string por eso nos devuelve true. OJO solo los compara en tipos. Si queremos saber su comparacion en valor y tipo debemos unsar triple igual (===).

    console.log(x === y); // false

OJO IMPORTANTE!!! - Lo recomendable siempre que podamos usar el triple igual (===) cuando tengamos que hacer comparaciones.

Ok ahora veamos como se comporta JS al comparar objetos.

    var sacha = {
        nombre: 'Sacha'
    }

    var otraPersona = {
        nombre: ' Sacha'
    }

Hacemos la comparacion

    console.log(sacha == otraPersona); //false
    console.log(sacha === otraPersona); //false

Muy diferente a lo de arriba que compara valores primitivos. Aqui la comparacion es de objetos, con (==) o (===) lo que hace JS es preguntar por la referencia de la variable que estamos utilizando. Si nos interesa que nos diera true la unica forma de hacerlo es como vemos a continuacion: La variable segundaPersona apunta a la misma referencia del primer objeto, osea el mismo espacio en memoria del ordenador

    var segundaPersona = sacha;
    console.log(sacha == segundaPersona); //true
    console.log(sacha === segundaPersona); //true

Ahora veamo con la creacion de otro objeto

    var terceraPersona = {
        ...sacha
    }

    console.log(sacha == terceraPersona); //false
    console.log(sacha === terceraPersona); //false

Como podemos ver da false porque dentro del objeto terceraPersona estamos creando un nuevo objeto, no es el mismo primer objeto y sus referencias son diferentes.

Ahora veamos otro ejemplo, tenemos un objeto inicial y un segundo objeto que apunta al primero si modificamos al segundo objeto tambien modificamos al primero ya que amb0s apuntan a la misma referencia:

    var obj1 = {
        nombre: 'Sacha'
    }
    console.log(sacha); // {nombre: "Sacha"}

    var obj2 = sacha;
    console.log(sacha); // {nombre: "Sacha"}

    sacha.nombre = 'Pepe';

    console.log(sacha); // {nombre: "Pepe"}

_______________________________________
10.CONDICIONALES EN JAVASCRIPT: if else
---------------------------------------
En esta clase empezaremos a trabajar con estructuras de control, éstas nos permiten decidir el flujo de nuestro código.

Empezaremos con los condicionales. Los condicionales nos permiten decidir si un código se ejecuta o no. También introducimos un nuevo tipo de datos primitivos: el booleano, que determina si un valor es falso o verdadero. Mediante un condicional (if) decidiremos si se ejecuta una parte de nuestro código cuando se cumpla o no cierta condición.


Las estructuras de control deciden si un codigo se ejecuta o no.

    let sacha = {
        nombre: 'Sacha',
        apellido: 'Lifszyc',
        edad: 16,
        ingeniero: false,
        cocinero: false,
        cantante: false,
        dj: false,
        guitarrista: false,
        drone: true
    }

Definimos una funcion que nos dice que profesion tiene una persona

    function imprimirProfesiones(persona){
    console.log(`${persona.nombre} es: `);

    if(persona.ingeniero === true)
        if(persona.ingeniero){
            console.log('Ingeniero.');
        } else {
            console.log('No es ingeniero.');
        }
        if(persona.cocinero){
            console.log('Cocinero.');
        }
        if(persona.cantante){
            console.log('Cantante.');
        }
        if(persona.dj){
            console.log('DJ.');
        }
        if(persona.drone){
            console.log('Piloto de drones.');
        }
    }

    imprimirProfesiones(sacha);

Como podemos ver con el if solo se ejecuta el codigo que es true.

Reto: escribir la funcion imprimirSiEsMayorDeEdad().

    function imprimirSiEsMayorDeEdad(persona){
        if(persona.edad >= 18){
            console.log(`${persona.nombre} es mayor de edad.`);
        } else {
            console.log(`${persona.nombre} es menor de edad.`);
        }
    }

    imprimirSiEsMayorDeEdad(sacha);

__________________________________
11.FUNCIONES QUE RETORNAN VALORES:
----------------------------------
En esta clase seguiremos trabajando con condicionales para desglosar las funciones en funciones más pequeñas que retornen un valor.

Debemos de tener en cuenta que el número 18 esta incluido dentro del rango de edad. Para ello utilizamos los símbolos >=.

Return detiene la ejecución de una función y devuelve el valor de esa función.

Las variables definidas con const se comportan como las variables, excepto que no pueden ser reasignadas. Las constantes pueden ser declaradas en mayúsculas o minúsculas. Pero por convención, para distinguirlas del resto de variables, se escribe todo en mayusculas.


    let sacha = {
        nombre: 'Sacha',
        apellido: 'Lifszyc',
        edad: 28,
        ingeniero: false,
        cocinero: false,
        cantante: false,
        dj: false,
        guitarrista: false,
        drone: true
    }

    let juan = {
        nombre: 'Juan',
        apellido: 'Gomez',
        edad: 13
    }

Definimos una funcion que nos dice que profesion tiene una persona

    function imprimirProfesiones(persona){
        console.log(`${persona.nombre} es: `);

    if(persona.ingeniero === true)
        if(persona.ingeniero){
            console.log('Ingeniero.');
        } else {
            console.log('No es ingeniero.');
        }
        if(persona.cocinero){
            console.log('Cocinero.');
        }
        if(persona.cantante){
            console.log('Cantante.');
        }
        if(persona.dj){
            console.log('DJ.');
        }
        if(persona.drone){
            console.log('Piloto de drones.');
        }
    }

    imprimirProfesiones(sacha);

Como podemos ver con el if solo se ejecuta el codigo que es true.

Reto: escribir la funcion imprimirSiEsMayorDeEdad().

Aqui creamos la logica de la mayoria de edad, devuelve true o false en funcion de la condicion del objeto

    const MAYORIA_DE_EDAD = 18;

OJO es comunmente las constantes declararlas asi en mayusculas y separadas por guiones bajos.

    function esMayorDeEdad(persona){
        return persona.edad >= MAYORIA_DE_EDAD;
    }

    function imprimirSiEsMayorDeEdad(persona){
        if(esMayorDeEdad(persona)){
            console.log(`${persona.nombre} es mayor de edad.`);
        } else {
            console.log(`${persona.nombre} es menor de edad.`);
        }
    }

    imprimirSiEsMayorDeEdad(sacha);
    imprimirSiEsMayorDeEdad(juan);

__________________
12.ARROW FUNCTION:
------------------
En esta clase aprenderemos a utilizar Arrow Functions que permiten una nomenclatura más corta para escribir expresiones de funciones. Este tipo de funciones deben definirse antes de ser utilizadas.

Al escribir las Arrow Functions no es necesario escribir la palabra function, la palabra return, ni las llaves.

    let sacha = {
        nombre: 'Sacha',
        apellido: 'Lifszyc',
        edad: 28,
        ingeniero: false,
        cocinero: false,
        cantante: false,
        dj: false,
        guitarrista: false,
        drone: true
    }

    let juan = {
        nombre: 'Juan',
        apellido: 'Gomez',
        edad: 13
    }

/Definimos una funcion que nos dice que profesion tiene una persona

    function imprimirProfesiones(persona){
        console.log(`${persona.nombre} es: `);

    if(persona.ingeniero === true)
        if(persona.ingeniero){
            console.log('Ingeniero.');
        } else {
            console.log('No es ingeniero.');
        }
        if(persona.cocinero){
            console.log('Cocinero.');
        }
        if(persona.cantante){
            console.log('Cantante.');
        }
        if(persona.dj){
            console.log('DJ.');
        }
        if(persona.drone){
            console.log('Piloto de drones.');
        }
    }

    imprimirProfesiones(sacha);

Como podemos ver con el if solo se ejecuta el codigo que es true.

Reto: escribir la funcion imprimirSiEsMayorDeEdad().

Aqui creamos la logica de la mayoria de edad, devuelve true o false en funcion de la condicion del objeto

    const MAYORIA_DE_EDAD = 18;

ojo es comunmente las constantes declararlas asi en mayusculas y separadas por guiones bajos.

Esta funcion asignada a una variable y la funcion es anonima:

    let esMayorDeEdad = function (persona){
        return persona.edad >= MAYORIA_DE_EDAD;
    }

Asi la podemos definir tambien como arrow function:
    const esMayorDeEdad = persona => persona.edad >= MAYORIA_DE_EDAD;


Haciendo desestructuracion del objeto porque solo necesitamos la edad

    const esMayorDeEdad = ({ edad }) => edad >= MAYORIA_DE_EDAD;

    function imprimirSiEsMayorDeEdad(persona){
        if(esMayorDeEdad(persona)){
            console.log(`${persona.nombre} es mayor de edad.`);
        } else {
            console.log(`${persona.nombre} es menor de edad.`);
        }
    }

    imprimirSiEsMayorDeEdad(sacha);
    imprimirSiEsMayorDeEdad(juan);


En JS existe otras maneras de expresar funciones:

- Podemos asignar a una variable una funcion y la funcion pasa a llamarse anonima, ya que no tiene nombre:

    let esMayorDeEdad = function (persona){
        return persona.edad >= MAYORIA_DE_EDAD;
    }

    esMayorDeEdad(persona);

- Tambien tenemos en JS las arrow function:
1- Cuando tenemos un solo parametro podemos obviar los parentesis.
2- JS tambien permite que si una funcion solo realiza un return podemos eliminar el return y las llaves.

    const esMayorDeEdad = persona => persona.edad >= MAYORIA_DE_EDAD;

Ahora vamos a permitir el acceso o no a una web:

    function permitirAcceso(persona) {
        if(!esMayorDeEdad(persona)){
            console.log('Acceso denegado');
        }
    }

    permitirAcceso(juan);
    permitirAcceso(sacha);

Reto escribir la funcion es menor de edad como arrow function y que retorne la negacion a la llamada esMayorDeEdad.

    const permitirEntrar = (persona) => {
        if(!esMayorDeEdad(persona)){
            console.log(`Lo siento ${persona.nombre}, no puedes entrar, eres menor de edad.`);
        } else {
            console.log(`Adelante ${persona.nombre}, puedes entrar, nunca pares de aprender.`);
        }
    }

    permitirEntrar(juan);
    permitirEntrar(sacha);


OJO Queda por ver un operador bastante intersante que se llama el operador ternario.

_____________
13.CICLO-FOR:
-------------
En esta clase estudiaremos una de las estructuras básicas de control. El bucle for, se utiliza para repetir una o más instrucciones un determinado número de veces.

Para escribir un bucle for se coloca la palabra for seguida de paréntesis y llaves.
Ej. for( ){ }. Dentro de los paréntesis irán las condiciones para ejecutar el bucle, y dentro las llaves irán las instrucciones que se deben repetir.

En este ejemplo la variable i la utilizamos como contador.

Ciclo for --> dentro del () inicializamos con un contador en nuestro caso la variable i, luego le damos la condicion, y luego el incremento que va a tener nuestro contador.
*/

En este ejercicio vamos a ver como una persona incrementa o disminuye su peso en un año de manera aleatoria usando la biblioteca de JS Math.

    let sacha = {
        nombre: 'Sacha',
        apellido: 'Lifszic',
        edad: 28,
        peso: 75
    }

    console.log(`Al inicio del año ${sacha.nombre} pesa ${sacha.peso} Kg.`);

    console.log(Math.random().toFixed(2));

    const PESO = 0.2;

El incremento de peso es de 200grs
const aumentarDePeso = persona => persona.peso += PESO;

La perdida de peso es de 200grs
const adelgazar = persona => persona.peso -=PESO;

    const DIAS_DEL_ANO = 365;

    for( let i = 1; i <= DIAS_DEL_ANO; i++) {
        let random = Math.random();

        if(random < 0.25){
            //aumenta de peso
            aumentarDePeso(sacha);
        }else if(random < 0.5) {
            // adelgazar
            adelgazar(sacha);
        }
    }

    console.log(`Al final del año ${sacha.nombre} pesa ${sacha.peso.toFixed(1)} Kg.`);

_______________
14.CICLO-WHILE:
---------------
En esta clase estudiaremos otra estructura repetitiva llamada while. While se ejecuta únicamente mientras la condición que se está evaluando es verdadera.

En ocasiones nuestro código puede fallar por errores de syntaxis o errores lógicos. En caso de que quieras verificar tu código, debes utilizar un debugger. El código se detiene cada vez que lee esta palabra.

    let sacha = {
        nombre: 'Sacha',
        apellido: 'Lifszic',
        edad: 28,
        peso: 75
    }

    console.log(`Al inicio del año ${sacha.nombre} pesa ${sacha.peso} Kg.`);


    const PESO = 0.3;
    const DIAS_DEL_ANO = 365;

El incremento de peso es de 200grs

    const aumentarDePeso = persona => persona.peso += PESO;

La perdida de peso es de 200grs

    const adelgazar = persona => persona.peso -=PESO;

Colocamos el ramdon en una funcion, come mucho por debajo del 30% de los dias

    const comeMucho = () => Math.random() < 0.3;

Hacemos un afuncion que realiza deporte, el 40% de los dias.

    const realizaDeporte = () => Math.random() < 0.4;

Debe perder 3 kg como meta a ver si la cumple

    const META = sacha.peso - 3;
    let dias = 0;

    while(sacha.peso > META){
        if(comeMucho()){
            //aumenta de peso
            aumentarDePeso(sacha);
        }
        if(realizaDeporte()) {
            //disminuye de
            adelgazar(sacha);
        }
        dias += 1;
    }

    console.log(`Pasaron ${dias} dias hasta que ${sacha.nombre} adelgazo 3Kg.`);

__________________
15.CICLO-DO-WHILE:
------------------
Otra estructura repetitiva es el do-while. A diferencia de la instrucción while, un bucle do…while se ejecuta una vez antes de que se evalúe la expresión condicional.

Debemos definir una variable contador.

Reto, resuelve el bug que tiene el ejercicio.

En argentina cuando una persona molesta mucho se le manda a la esquina a ver si llueve

let contador = 0;

Llueve el 25% del tiempo

    const llueve = () => Math.random() < 0.35;

    do {
        contador++;
    } while (!llueve());

Resolucion del bug, cuando imprime 1 veces debe ser vez.

    let frecuencia;

    if(contador === 1) {
        frecuencia = 'vez';
    } else {
        frecuencia = 'veces'
    }

    console.log(`Fui a ver si llovia ${contador} ${frecuencia}.`);


______________________
15.CONDICIONAL SWITCH:
----------------------
Una ultima estructura de control se llama switch. Switch se utiliza para realizar diferentes acciones basadas en múltiples condiciones.

Prompt, muestra un cuadro de mensaje que le pide al usuario que ingrese algúna información.

Break, sirve para que el browser se salte un bucle.

Vamos a decirle el horoscopo al usuario. Usaremos un web de referencia:

https://www.lanacion.com.ar/horoscopo

let signo = prompt('¿Cual es tu signo?');
console.log(signo);

let aries = 'Antes de avanzar, primero deberá tener en claro a dónde quiere llegar. Sepa que contará con el empuje necesario para conquistar todo lo que desee.';
let tauro = 'Si usted pretende cumplir con todos los objetivos, debería poner más entusiasmo en lo que hace. Evite relajarse, ya que podría perder cualquier oportunidad.';
let geminis = 'Deje de cometer siempre el mismo error al desvalorizarse continuamente. Aunque usted no lo vea, sus méritos son muy bien reconocidos por la gente que lo rodea.';
let cancer = 'Será una jornada donde se enfrentará con demasiadas opciones y tendrá que decidir la más conveniente. Relájese y espere a mañana para la determinación.';
let leo = 'Transitará un excelente momento para poner todo su esfuerzo y apostar a las cosas materiales con las que siempre soñó. Gracias a su inteligencia lo conseguirá.';
let virgo = 'Prepárese, ya que será una excelente jornada para concretar esos proyectos pendientes que hace tiempo tiene y se le dificultó alcanzar por su irresponsabilidad.';
let libra = 'Ponga todo su entusiasmo para poder concretar las metas. Ante todo, deberá tener en claro qué es lo que quiere realmente y esforzarse por conseguirlo.';
let escorpio = 'No quiera volver a vivir sus viejas historias, intente abandonar su pasado. Comience a sobrellevar el presente de otra manera y se sentirá menos angustiado.';
let sagitario = 'Momento oportuno para que empiece a creer en su imaginación que será indispensable para resolver cualquiera de los inconvenientes que aparezcan.';
let capricornio = 'Sepa que hoy despertará con mucha energía y con ganas de encontrar la felicidad después de tanto sufrimiento. Aproveche que se sentirá más jovial que nunca.';
let acuario = 'Después de tantos inconvenientes, sería óptimo que organice adecuadamente su vida personal. Haga los cambios que crea necesarios comenzando por su hogar.';
let piscis = 'Transitará un día fuera de lo común donde podrá aplicar su lado más perceptivo y libre. Haga lo que haga, se sentirá espléndido. Nadie podrá opacarlo.';

switch (signo) {
    case 'aries':
        console.log(aries);
    break;
    case 'tauro':
        console.log(tauro);
    break;
    case 'geminis':
    case 'géminis':
        console.log(geminis);
    break;
    case 'cancer':
        console.log(cancer);
    break;
    case 'leo':
        console.log(leo);
    break;
    case 'libra':
        console.log(libra);
    break;
    case 'virgo':
        console.log(virgo);
    break;
    case 'escorpio':
        console.log(escorpio);
    break;
    case 'sagitario':
        console.log(sagitario);
    break;
    case 'capricornio':
        console.log(capricornio);
    break;
    case 'piscis':
        console.log(piscis);
    break;
    default:
        console.log('Ese signo zodiacal no es valido');
    break;
}

______________________
16.CONDICIONAL SWITCH: MULTIPLES SWITCH:
----------------------
Vamos a decir que dentro de nuestro case podemos usar multiples variables de control como vemos a continuacion:

switch (signo) {
    case 'aries':
        console.log(aries);
    break;
    case 'tauro':
        console.log(tauro);
    break;
    case 'geminis':
    case 'géminis':
        console.log(geminis);
    break;
    case 'cancer':
        console.log(cancer);
    break;
    case 'leo':
        console.log(leo);
    break;
    case 'libra':
        console.log(libra);
    break;
    case 'virgo':
        console.log(virgo);
    break;
    case 'escorpio':
        console.log(escorpio);
    break;
    case 'sagitario':
        console.log(sagitario);
    break;
    case 'capricornio':
        console.log(capricornio);
    break;
    case 'piscis':
        console.log(piscis);
    break;
    default:
        console.log('Ese signo zodiacal no es valido');
    break;
}

_____________________________
17.INTRODUCCION A LOS ARRAYS:
-----------------------------
Los arrays son estructuras que nos permiten organizar elementos dentro de una collección. Estos elementos pueden ser números, strings, booleanos, objetos, etc.


    let sacha = {
        nombre: 'Sacha',
        apellido: 'Lifszyc',
        altura: 1.72
    }
    let alan = {
        nombre: 'Alan',
        apellido: 'Perez',
        altura: 1.86
    }
    let martin = {
        nombre: 'Martin',
        apellido: 'Gomez',
        altura: 1.85
    }
    let dario= {
        nombre: 'Dario',
        apellido: 'Juarez',
        altura: 1.71
    }
    let vicky = {
        nombre: 'Vicky',
        apellido: 'Zapata',
        altura: 1.56
    }
    let paula = {
        nombre: 'Paula',
        apellido: 'Barros',
        altura: 1.76
    }

Podemos agrupar a todos dentro de una misma variable

    let personas = [sacha, alan, martin, dario, vicky, paula];

    console.log(personas); // Accedemos a todo el array
    console.log(personas[0]); // Accedemos a cada elemento del array por medio de su indice

    console.log(personas[0].altura); // Para acceder por indice y a un atributo del objeto

    console.log(personas[5]['nombre']); // Otra forma de acceder a los atributos.

Ahora podemos recorrer el array y imprimir la altura de cada uno de ellos.

    for(let i = 0; i < personas.length; i++){
        let persona= personas[i];
        // console.log(personas[i]);
        console.log(`${persona.nombre} mide: ${persona.altura} mts.`);
    }


18.FILTRAR UN ARRAY:
--------------------
En esta clase aprenderemos como filtrar los arrays. Para filtrar siempre necesitamos establecer una condición. En este ejemplo nuestra condición es que la estatura de las personas sea mayor de 1.80mts.

El método filter( ) crea una nueva matriz con todos los elementos que pasan la prueba implementada por la función proporcionada.

Recuerda que si no hay elementos que pasen la prueba, filter devuelve un array vacío.

Reto: escribe el filtrado de personas bajas.

    let sacha = {
        nombre: 'Sacha',
        apellido: 'Lifszyc',
        altura: 1.72
    }
    let alan = {
        nombre: 'Alan',
        apellido: 'Perez',
        altura: 1.86
    }
    let martin = {
        nombre: 'Martin',
        apellido: 'Gomez',
        altura: 1.85
    }
    let dario= {
        nombre: 'Dario',
        apellido: 'Juarez',
        altura: 1.71
    }
    let vicky = {
        nombre: 'Vicky',
        apellido: 'Zapata',
        altura: 1.56
    }
    let paula = {
        nombre: 'Paula',
        apellido: 'Barros',
        altura: 1.76
    }

Podemos agrupar a todos dentro de una misma variable: Un array de personas:

    let personas = [sacha, alan, martin, dario, vicky, paula];

Vamos a filtrar de nuestro array las personas altas. Para filtrar necesitamos dos cosas, un array y una condicion, esta condicion sera una funcion.

Usaremos el metodo filter(condicion) para arrays la cual recibe como parametro una condicion. OJO filter() nos devuelve un array nuevo si se cumplen las condiciones. Sino el array estara vacio.

    const ALTURA = 1.8;

    const esAlta = persona =>  persona.altura > ALTURA;

    let personasAltas = personas.filter(esAlta);
    console.log(personasAltas);

________________________
19.TRANSFORMAR UN ARRAY:
------------------------
En esta clase veremos cómo transformar un array. El método map() itera sobre los elementos de un array en el orden de inserción y devuelve array nuevo con los elementos modificados.

    let sacha = {
        nombre: 'Sacha',
        apellido: 'Lifszyc',
        altura: 1.72
    }
    let alan = {
        nombre: 'Alan',
        apellido: 'Perez',
        altura: 1.86
    }
    let martin = {
        nombre: 'Martin',
        apellido: 'Gomez',
        altura: 1.85
    }
    let dario= {
        nombre: 'Dario',
        apellido: 'Juarez',
        altura: 1.71
    }
    let vicky = {
        nombre: 'Vicky',
        apellido: 'Zapata',
        altura: 1.56
    }
    let paula = {
        nombre: 'Paula',
        apellido: 'Barros',
        altura: 1.76
    }

Podemos agrupar a todos dentro de una misma variable:

    let personas = [sacha, alan, martin, dario, vicky, paula];

Vamos a transformar nuestro array original y pasaremos la altura de cada objeto de mts a cm. OJO se modifica el array original.

    const pasarAlturaACms = persona => {
        /* persona.altura = persona.altura * 100;
        persona.altura *= 100;  Estas dos lineas son iguales */
        // return persona;

        // Asi a continuacion no modificamos el array original

        return {
            ...persona,
            altura: persona.altura * 100
        };
    }

    let personasCms = personas.map(pasarAlturaACms)
    console.log(personasCms);
    console.log(personas);

    console.log(personas[0] === personasCms[0]); // false

____________________
20.REDUCIR UN ARRAY:
--------------------
El método reduce() nos permite reducir, mediante una función que se aplica a cada uno de los elemento del array, todos los elementos de dicho array, a un valor único.

    let sacha = {
        nombre: 'Sacha',
        apellido: 'Lifszyc',
        altura: 1.72,
        cantidadDeLibros: 78
    }
    let alan = {
        nombre: 'Alan',
        apellido: 'Perez',
        altura: 1.86,
        cantidadDeLibros: 132
    }
    let martin = {
        nombre: 'Martin',
        apellido: 'Gomez',
        altura: 1.85,
        cantidadDeLibros: 90
    }
    let dario= {
        nombre: 'Dario',
        apellido: 'Juarez',
        altura: 1.71,
        cantidadDeLibros: 91
    }
    let vicky = {
        nombre: 'Vicky',
        apellido: 'Zapata',
        altura: 1.56,
        cantidadDeLibros: 182
    }
    let paula = {
        nombre: 'Paula',
        apellido: 'Barros',
        altura: 1.76,
        cantidadDeLibros: 111
    }

Podemos agrupar a todos dentro de una misma variable

    let personas = [sacha, alan, martin, dario, vicky, paula];

Vamos usando el metodo reduce() sacar la cuenta total de cuantos libros hay.

Por medio de un ciclo for

    let acum = 0;
    for(let i = 0; i < personas.length; i++){
        acum = acum + personas[i].cantidadDeLibros;
        console.log(acum);
    }
    console.log(`El total de libros es: ${acum}`);

Ahora usaremos el metodo reduce(), la cual recibe por parametros una funcion, le ponemos el nombre que queramos y el valor inicial del acumulador que es cero para nuestro caso.

Esta funcion recibe dos parametros, uno el acumulador(acumulador)
funcion original

    const reducer = (acumulador, persona) => {
        return acumulador + persona.cantidadDeLibros;
    }

Funcion simplificada, quitando el return y desestructurando el objeto

    const reducer = (acumulador, { cantidadDeLibros }) =>  acumulador + cantidadDeLibros;

    let totalDelibros = personas.reduce(reducer, 0);
    console.log(`El total de libros es: ${totalDelibros}`);

___________________________
21.PROTOTYPE EN JAVASCRIPT:
---------------------------
Las clases son funciones cuya sintaxis tiene dos componentes:

    expresiones
    declaraciones

En esta clase veremos el uso de this. Dentro de una función, el valor de this depende de cómo es llamada ésta.

Reto: agrega el atributo altura y la función soyAlto.

Cuando hablamos de objetos en JS estamos hablando de prototypos y no tanto de clases.

En las nuevas versiones de JS ya existen las clases pero estas no son como las podemos conocer en otros lenguajes de programacion, no existe la herencia como tal. Pero si existen los prototypos


Vamos a crear un prototipo de persona que va a saludar.

Aqui tenenos el prototipo de Persona()

    function Persona(nomb, apell, alt) {
        this.nombre = nomb;
        this.apellido = apell;
        this.altura = alt;
    }

Para guardarlo dentro del objeto que se esta construyendo en la memoria podemos hacemos referencia dentro de la funcion como --> this, este hace referencia la objeto que se acaba de construir

Dentro del prototipo de persona va existir un atributo saludar

    Persona.prototype.saludar = function(){
        console.log(`Hola, me llamo ${this.nombre} ${this.apellido}.`)
    }

RETO: Agregamos el atributo de altura dentro del prototipo Persona()

    Persona.prototype.soyAlto = function(){
        const ALTURA = 1.8;
        if (this.altura > ALTURA){
            console.log(`Mido más de 1.8 mts y soy alto.`);
        } else {
            console.log(`Mido menos de 1.8 mts y soy bajo.`)
        }
    }

Asi creamos objetos dado un prototipo, la palabre new es reservada del lenguaje y lo que hace es crear un nuevo objeto que ira asigando al prototipo que asignemos despues, en nuestro caso Persona()

    let sacha = new Persona('Sacha', 'Lifszyc', 1.9);
    console.log(sacha);
    sacha.saludar();
    sacha.soyAlto();


Asi creamos mas facilmente mas objetos

    let erika = new Persona('Erika', 'Luna');
    erika.saludar();
    erika.soyAlto()

    let arturo = new Persona('Arturo', 'Martinez');
    arturo.saludar();
    arturo.soyAlto();


Reto: agregar al constructor el atributo altura, tambien agregar la funcion soy alto y que lo retorne si mide 1.8mts

__________________________
22.MODIFICAR UN PROTOTIPO:
--------------------------
En esta clase veremos cómo se modifican las clases de herencias. JavaScript funciona con una estructura orientada a objetos y cada objeto tiene una propiedad privada que mantiene un enlace a otro objeto llamado prototipo.


Vamos a crear un prototipo de persona que va a saludar.

Aqui tenenos el prototipo de Persona()

    function Persona(nomb, apell, alt) {
        // Para guardarlo dentro del objeto que se esta construyendo en la memoria podemos hacemos referencia dentro de la funcion como --> this, este hace referencia la objeto que se acaba de construir
        this.nombre = nomb;
        this.apellido = apell;
        this.altura = alt;
    }

Dentro del prototipo de persona va existir un atributo saludar

    Persona.prototype.saludar = function(){
        console.log(`Hola, me llamo ${this.nombre} ${this.apellido}.`)
    }

RETO: Agregamos el atributo de altura dentro del prototipo Persona()

    Persona.prototype.soyAlto = function(){
        const ALTURA = 1.8;
        if (this.altura > ALTURA){
            console.log(`Mido más de 1.8 mts y soy alto.`);
        } else {
            console.log(`Mido menos de 1.8 mts y soy bajo.`)
        }
    }

Asi creamos objetos dado un prototipo, la palabre new es reservada del lenguaje y lo que hace es crear un nuevo objeto que ira asigando al prototipo que asignemos despues, en nuestro caso Persona()

    let sacha = new Persona('Sacha', 'Lifszyc', 1.9);
    let erika = new Persona('Erika', 'Luna', 1.65);
    let arturo = new Persona('Arturo', 'Martinez', 1.89);

    sacha.saludar();
    sacha.soyAlto();

    erika.saludar();
    erika.soyAlto()

    arturo.saludar();
    arturo.soyAlto();


Nota:
- Los prototypos debemos definirlos todos juntos despues del constructor.
- dentro del prototypo no usar arrow function, ya que no tiene el comportamiento correcto con this. Eso queda mas claro en el siguiente video.
*/

_______________________________________________
23.EL CONTEXTO DE LAS FUNCIONES, QUIEN ES THIS:
-----------------------------------------------
En esta clase veremos cómo se modifican las clases de herencias. JavaScript funciona con una estructura orientada a objetos y cada objeto tiene una propiedad privada que mantiene un enlace a otro objeto llamado prototipo.


Vamos a crear un prototipo de persona que va a saludar.

Aqui tenenos el prototipo de Persona()

    function Persona(nomb, apell, alt) {
        // Para guardarlo dentro del objeto que se esta construyendo en la memoria podemos hacemos referencia dentro de la funcion como --> this, este hace referencia la objeto que se acaba de construir
        this.nombre = nomb;
        this.apellido = apell;
        this.altura = alt;
    }

Dentro del prototipo de persona va existir un atributo saludar

    Persona.prototype.saludar = function(){
        console.log(`Hola, me llamo ${this.nombre} ${this.apellido}.`)
    }

Asi es en arrow function NO HACER CAMBIA A THIS

    Persona.prototype.soyAlto = ()  => this.altura > 1.8;

Cuando usamos arrow function como anteriormente this pasa a ser windows, y este es el objeto global dentro del navegador, si buscamos yhis.altura dentro de windows es undefined y nunca undefined es mayor que 1.8 mtrs por eso cuando llamamos soyAlto() para cada objeto creado sale false. sacha.soyAlto() --> false

Esto de que this no es lo que esperabamos es de los errores mas comunes que podemos encontrar en JS


Asi creamos objetos dado un prototipo, la palabre new es reservada del lenguaje y lo que hace es crear un nuevo objeto que ira asigando al prototipo que asignemos despues, en nuestro caso Persona()

    let sacha = new Persona('Sacha', 'Lifszyc', 1.9);
    let erika = new Persona('Erika', 'Luna', 1.65);
    let arturo = new Persona('Arturo', 'Martinez', 1.89);

    sacha.saludar();
    sacha.soyAlto();

    erika.saludar();
    erika.soyAlto()

    arturo.saludar();
    arturo.soyAlto();


Nota:
- Los prototypos debemos definirlos todos juntos despues del constructor.
- dentro del prototypo no usar arrow function, ya que no tiene el comportamiento correcto con this. Eso queda mas claro en el siguiente video.
*/

___________________________________________________
24.LA VERDAD OCULTA SOBRE LAS CLASES EN JAVASCRIPT:
---------------------------------------------------
¿Como hago para que un prototipo herede de otro?

Los objetos en JavaScript son “contenedores” dinámicos de propiedades. Estos objetos poseen un enlace a un objeto prototipo. Cuando intentamos acceder a la propiedad de un objeto, la propiedad no sólo se busca en el propio objeto sino también en el prototipo del objeto, en el prototipo del prototipo, y así sucesivamente hasta que se encuentre una propiedad que coincida con el nombre o se alcance el final de la cadena de prototipos.


Bastante complejo de entender, necesitamos crear esta funcion.

    function heredaDe(protipoHijo, prototipoPadre){
        // Aqui le decimos al hijo quien es el padre
        let fn = function() {}; // Creamos una funcion vacia
        fn.prototype = prototipoPadre.prototype;
        protipoHijo.prototype = new fn;
        protipoHijo.prototype.constructor = protipoHijo;
    }

Aqui tenenos el prototipo de Persona()

    function Persona(nomb, apell, alt) {
        this.nombre = nomb;
        this.apellido = apell;
        this.altura = alt;
    }

Dentro del prototipo de persona va existir un atributo saludar(metodo)
    Persona.prototype.saludar = function(){
        console.log(`Hola, me llamo ${this.nombre} ${this.apellido}.`)
    }

    Persona.prototype.soyAlto = function(){
        const ALTURA = 1.8;
        if (this.altura > ALTURA){
            console.log(`Mido más de 1.8 mts y soy alto.`);
        } else {
            console.log(`Mido menos de 1.8 mts y soy bajo.`)
        }
    }

Herencia prototipal en JS. Desarrollador

    function Desarrollador(nomb, apell){
        this.nombre = nomb;
        this.apellido = apell;
    }

    heredaDe(Desarrollador, Persona);

    Desarrollador.prototype.saludar = function(){
        console.log(`Hola me llamo ${this.nombre} ${this.apellido} y soy Desarrollador/a.`);
    }

Desarrollador -----------------------------------------

Creamos los objetos

    let sacha = new Persona('Sacha', 'Lifszyc', 1.9);
    let erika = new Persona('Erika', 'Luna', 1.65);
    let arturo = new Persona('Arturo', 'Martinez', 1.89);
    sacha.saludar();
    sacha.soyAlto();

Creamos un objeto desarrollador

    let mariano = new Desarrollador('Mariano', 'Marques', 1.75)
    mariano.saludar();
    mariano.soyAlto();

______________
25.LAS CLASES:
--------------
Las clases de JavaScript son introducidas en el ECMAScript 2015 y son una mejora en la sintaxis sobre la herencia basada en prototipos de JavaScript.

La palabra clave extends se usa en declaraciones de clase o expresiones de clase para crear una clase que es hija de otra clase.

El método constructor es un método especial para crear e inicializar un objeto creado a partir de una clase.


Asi creamo la clase Persona y que tiene un metodo llamado constructor, que es el que se va ejecutar al crear objetos de esta clase.

    class Persona {
        constructor(nomb, apell, alt){
            this.nombre = nomb;
            this.apellido = apell;
            this.altura = alt;
        }
        saludar() {
            console.log(`Hola, me llamo ${this.nombre} ${this.apellido}.`);
        }
        soyAlto() {
            const ALTURA = 1.8;
            if (this.altura > ALTURA){
                console.log(`Mido más de 1.8 mts y soy alto.`);
            } else {
                console.log(`Mido menos de 1.8 mts y soy bajo.`);
            }
        }
    }

Asi hacemos que una clase herede de otra, nuestro caso el desarrollador de persona

    class Desarrollador extends Persona {
        constructor(nomb, apell, alt, nacionalidad) {
            super(nomb, apell, alt); // Las que tiene el padre
            this.nacionalidad = nacionalidad; // Las suyas en particular
        }
        saludar() {
            console.log(`Hola me llamo ${this.nombre} ${this.apellido} y soy Desarrollador/a.`);
        }

        pais(){
            console.log(`Me llamo ${this.nombre} y soy de ${this.nacionalidad}.`)
        }
    }

Desarrollador -----------------------------------------

Creamos los objetos

    let sacha = new Persona('Sacha', 'Lifszyc', 1.9);
    let erika = new Persona('Erika', 'Luna', 1.65);
    let arturo = new Persona('Arturo', 'Martinez', 1.89);
    sacha.saludar();
    sacha.soyAlto();

Creamos un objeto desarrollador

    let mariano = new Desarrollador('Mariano', 'Marques', 1.75, 'Venezuela');
    mariano.saludar();
    mariano.soyAlto();
    mariano.pais()

____________________________
26.FUNCIONES COMO PARAMETROS:
----------------------------
En JavaScript, los parámetros de funciones son por defecto undefined. De todos modos, en algunas situaciones puede ser útil colocar un valor por defecto diferente que lo evalúe como verdadero.


Asi creamo la clase Persona y que tiene un metodo llamado constructor, que es el que se va ejecutar al crear objetos de esta clase.

    class Persona {
        constructor(nomb, apell, alt){
            this.nombre = nomb;
            this.apellido = apell;
            this.altura = alt;
        }

recibe una funcion por parametro al ser llamada

    saludar(fn) {
        let { nombre, apellido } = this;// Otra manera de poner mas limpio
        // console.log(`Hola, me llamo ${this.nombre} ${this.apellido}.`);
        console.log(`Hola, me llamo ${nombre} ${apellido}.`);

        if(fn){
            fn(nombre,apellido);// Al no pasar el tercer paramatro evalua false y no se ejecuta abajo el saludo de dev
        }
    }

    soyAlto() {
        const ALTURA = 1.8;
        if (this.altura > ALTURA){
            console.log(`Mido más de 1.8 mts y soy alto.`);
        } else {
            console.log(`Mido menos de 1.8 mts y soy bajo.`);
        }
    }
}

Asi hacemos que una clase herede de otra, nuestro caso el desarrollador de persona

    class Desarrollador extends Persona {
        constructor(nomb, apell, alt, nacionalidad) {
            super(nomb, apell, alt); // Las que tiene el padre
            this.nacionalidad = nacionalidad; // Las suyas en particular
        }
        saludar(fn) {
            let { nombre, apellido } = this;
            // console.log(`Hola me llamo ${this.nombre} ${this.apellido} y soy Desarrollador/a.`);
            console.log(`Hola me llamo ${nombre} ${apellido} y soy Desarrollador/a.`);
            if(fn){
                fn(nombre,apellido,true); // true le dice que si es dev
            }
        }

        pais(){
            console.log(`Me llamo ${this.nombre} y soy de ${this.nacionalidad}.`)
        }
    }

Funciones como parametro, Muy interesante, creamos una funcion para que nos responda el saludo si somos desarrolladores y si no lo somos no responde solo saluda.

    function responderSaludo(nombre, apellido, esDev) {
        console.log(`Buen día ${nombre} ${apellido}.`);
        if(esDev){
            console.log(`Ahh ok!!! No sabia que eras desarrollador/a.`);
        }
    }

Creamos los objetos

    let susana = new Persona('Susana', 'Serrano', 45);
    susana.saludar(responderSaludo);

    let alfredo = new Desarrollador('Alfredo', 'Sánchez', 45,);
    alfredo.saludar(responderSaludo);

_______________________________________________
27.COMO FUNCIONA EL ASINCRONISMO EN JAVASCRIPT:
-----------------------------------------------
JavaScript sólo puede hacer una cosa a la vez, sin embargo; es capaz de delegar la ejecución de ciertas funciones a otros procesos. Este modelo de concurrencia se llama EventLoop.

JavaScript delega en el navegador ciertas tareas y les asocia funciones que deberán ser ejecutadas al ser completadas. Estas funciones se llaman callbacks, y una vez que el navegador ha regresado con la respuesta, el callback asociado pasa a la cola de tareas para ser ejecutado una vez que JavaScript haya terminado todas las instrucciones que están en la pila de ejecución.

Si se acumulan funciones en la cola de tareas y JavaScript se encuentra ejecutando procesos muy pesados, el EventLoop quedará bloqueado y esas funciones pudieran tardar demasiado en ejecutarse.

_________________________________________
28.COMO FUNCIONA EL TIEMPO EN JAVASCRIPT:
-----------------------------------------
En principio, cualquier tarea que se haya delegado al navegador a través de un callback, deberá esperar hasta que todas las instrucciones del programa principal se hayan ejecutado. Por esta razón el tiempo de espera definido en funciones como setTimeout, no garantizan que el callback se ejecute en ese tiempo exactamente, sino en cualquier momento a partir de allí, sólo cuando la cola de tareas se haya vaciado.


Veamos el tema del tiempo en JS, queremos que el segundo console lo ejecute pasado un tiempo. Usaremos una funcion del lenguaje setTimeout() que recibe dos parametros uno es una funcion y el otro el tiempo en milisegundos.

    console.log('a');

    setTimeout(function(){
        console.log('b');
    },0)

    console.log('c');

NOTA. Si en vez de los 3000 ms le ponemos 0, vemos que se imprimen al instante pero.... imprime a,c,b eso porque el segundo console es enviado al navegador y este la envia a la cola de tareas y Js se continua ejecutando el resto del codigo y cuando finaliza es que le pide al navegador que tarea tiene pendiente y le envia la funcion.

/Ahora veamos otro ejemplo:

/Tenemos una funcion que se ejecuta pasados 2seg, Como vemos se ejecuta sin problemas

    setTimeout(()=> console.log('d'),2000);

Ahora que pasa si tenemos mas codigo a continuacion y este tarda en ejecutarse

    for(let i = 0; i < 10000000000; i++){

    }

Como podemos ver JS sigue ejecutandose pEro hasta que no se termine de Ejecutar el ciclo for no va a ejecutar el setTimeOut, el ciclo for bloquea el event loop y hasta que este no termine no se ejecutara luego el setTimeout.

_____________
29.CALLBACKS:
-------------
En esta clase aprenderemos que son los callbacks y usaremos una librería externa que se llama jQuery.

Un callback es una función que se pasa a otra función como un argumento. Esta función se invoca, después, dentro de la función externa para completar alguna acción.


Usaremos un libreria externa llamada jQuery

Usaremos la API de https://swapi.dev/

Vamos hacer el request para obtener los datos de la API

    const API_URL = 'https://swapi.dev/api/';
    const PEOPLE_URL = 'people/:id';

    const lukeUrl = `${API_URL}${PEOPLE_URL.replace(':id', 1)}`;
    const opts = { crossDomain: true};


Arguments es una variable que tienen todas las funciones y nos devuelve un array con los parametros que recibe la funcion

    const onResponse = function(data) {
        console.log(arguments); // Sabemos que parametros podemos traer-->data es el que nos interesa, no lo dice la documentacion de jQuery
        console.log(`Hola yo soy ${data.name}.`);
    }


Asi es con jQuery hace la peticion a la API.

    $.get(lukeUrl, opts, onResponse);


Ejemplo de arguments:

    function leer(libro){
        console.log(arguments);
    }

    leer();

______________________________
30.HACIENDO MULTIPLES REQUEST:
------------------------------
En esta clase accederemos a múltiples datos al mismo tiempo. Continuaremos trabajando con los jQuery y swapi.


Usaremos un libreria externa llamada jQuery como ayuda.

Usaremos la API de https://swapi.dev/

Vamos hacer el request para obtener los datos de la API

    const API_URL = 'https://swapi.dev/api/';
    const PEOPLE_URL = 'people/:id';

    const opts = { crossDomain: true};

Vamos hacer una funcion que logee los nombres de multiples personajes y en paralelo

    function obtenerPersonaje(id){
        const url = `${API_URL}${PEOPLE_URL.replace(':id', id)}`;
        $.get(url, opts, onResponse);
    }


arguments es una variable que tienen todas las funciones y nos devuelve un array con los parametros que recibe la funcion

    const onResponse = function(data) {
        //console.log(arguments); // Sabemos que parametros podemos traer-->data es el que nos interesa, no lo dice la documentacion de jQuery
        console.log(`Hola, yo soy ${data.name}.`);
    }

Ahora obtenemos los personajes

    obtenerPersonaje(1);
    obtenerPersonaje(2);
    obtenerPersonaje(3);
    obtenerPersonaje(4);
    obtenerPersonaje(5);

OJO con esto el orden con que se muestran los personajes es varible nunca en el orden porque debido al asincronismo de JS basicamente como la peticion es en paralelo esta entregando por consola el personaje que el servidor entrega primero.

_______________________________________________________
31.MANEJANDO EL ORDEN Y EL ASINCRONISMOS EN JAVASCRIPT:
-------------------------------------------------------
Una manera de asegurar que se respete la secuencia en que hemos realizado múltiples tareas es utilizando callbacks, con lo que se ejecutará luego, en cada llamada. Lo importante es que el llamado al callback se haga a través de una función anónima. Sin embargo, al hacerlo de esta manera generamos una situación poco deseada llamada CallbackHell. El infierno de los callbacks.


Usaremos un libreria externa llamada jQuery como ayuda.

Usaremos la API de https://swapi.dev/

Vamos hacer el request para obtener los datos de la API

    const API_URL = 'https://swapi.dev/api/';
    const PEOPLE_URL = 'people/:id';

    const opts = { crossDomain: true};

Vamos hacer una funcion que logee los nombres de multiples personajes y en paralelo

    function obtenerPersonaje(id, callback){
        const url = `${API_URL}${PEOPLE_URL.replace(':id', id)}`;

        $.get(url, opts, function(data) {
        console.log(`Hola, yo soy ${data.name}.`);

        if(callback){
            callback();
        }
    });

    }

Para controlar el orden lo haremos por medio de una funcion que pasaremos arriba como callback, los request se hacen en serie no en paralelo como antes.

obtenerPersonaje(1,function(){
    obtenerPersonaje(2,function(){
        obtenerPersonaje(3,function(){
            obtenerPersonaje(4,function(){
                obtenerPersonaje(5, function(){
                    obtenerPersonaje(6,function(){
                        obtenerPersonaje(7);
                    });
                });
            });
        });
    });
})

___________________________________
32.MANEJO DE ERRORES CON CALLBACKS:
-----------------------------------
Para solucionar el problema de quedarnos sin conexión, u otro error similar, en medio de una sucesión de callbacks utilizamos el método fail().


Usaremos un libreria externa llamada jQuery como ayuda.

Usaremos la API de https://swapi.dev/

Vamos hacer el request para obtener los datos de la API

    const API_URL = 'https://swapi.dev/api/';
    const PEOPLE_URL = 'people/:id';

    const opts = { crossDomain: true};

Vamos hacer una funcion que logee los nombres de multiples personajes y en paralelo

    function obtenerPersonaje(id, callback){
        const url = `${API_URL}${PEOPLE_URL.replace(':id', id)}`;
        // Ahora podemos encadenar con el metodo fail()
        $
        .get(url, opts, callback)
        // Asi podemos capturar el error por si hay perdida de conexion o por si uno de los personajes no existe.
        .fail(function(){
            console.log(`Sucedio un error no se pudo obtener el personaje ${id}`)
        })

    }

Para controlar el orden lo haremos por medio de una funcion que pasaremos arriba como callback, los request se hacen en serie no en paralelo como antes.

Hacemos un refactorings de la funcion.

    obtenerPersonaje(1,function(data){
        console.log(`Hola, yo soy ${data.name}.`);
        obtenerPersonaje(2,function(data){
            console.log(`Hola, yo soy ${data.name}.`);
            obtenerPersonaje(3,function(data){
                console.log(`Hola, yo soy ${data.name}.`);
                obtenerPersonaje(4,function(data){
                    console.log(`Hola, yo soy ${data.name}.`);
                    obtenerPersonaje(5, function(data){
                        console.log(`Hola, yo soy ${data.name}.`);
                        obtenerPersonaje(6,function(data){
                            console.log(`Hola, yo soy ${data.name}.`);
                            obtenerPersonaje(7777, function(data){
                                console.log(`Hola, yo soy ${data.name}.`);
                            });
                        });
                    });
                });
            });
        });
    })

____________
33.PROMESAS:
------------
Las promesas llegan para resolver el llamado de los callbacks, que estan bien pero cuando llegamos al callbacks hell el codigo se hace bastante confuso y dificil de manejar.

En esta clase veremos las promesas, que son valores que aun no conocemos. Las promesas tienen tres estados:

- pending
- fullfilled
- rejected

Las promesas se invocan de la siguiente forma:

    new Promise((resolve, reject){
        // llamado asincrono
        if(todoOk){
            // Se resuelve la promesa
            resolve()
        } else {
            // Paso algo
            reject()
        }
    })

No olvides ver el material adjunto de esta clase. PDF.


Vamos hacer el request para obtener los datos de la API

    const API_URL = 'https://swapi.dev/api/';
    const PEOPLE_URL = 'people/:id';

    const opts = { crossDomain: true};

    function obtenerPersonaje(id){
        return new Promise(function(resolve, reject){
            const url = `${API_URL}${PEOPLE_URL.replace(':id', id)}`;
            $
            .get(url, opts, function(data){
                resolve(data);
            })
            .fail(function(){
                reject(id);
            })
        })

    }

    obtenerPersonaje(1)
        .then(function(data){
            console.log(`Hola, yo soy ${data.name}.`);
        })
        .catch(function(id){
            console.log(`Ha sucedido un error en obtener el personaje ${id}`);
        })

_________________________________
34.PROMESAS ENCADENADAS EN SERIE:
---------------------------------
A diferencia de los callbacks en el CallbackHell, que terminan estando anidados unos dentro de otros, cuando se usan Promesas la ejecución de las llamadas no se hacen de manera anidada sino de manera encadenada, al mismo nivel una debajo de la otra, lo que hace que el código sea mucho más legible y mantenible.


Vamos hacer el request para obtener los datos de la API

    const API_URL = 'https://swapi.dev/api/';
    const PEOPLE_URL = 'people/:id';

    const opts = { crossDomain: true};

    function obtenerPersonaje(id){
        return new Promise(function(resolve, reject){
            const url = `${API_URL}${PEOPLE_URL.replace(':id', id)}`;
            $
            .get(url, opts, function(data){
                resolve(data);
            })
            .fail(function(){
                reject(id);
            })
        })
    }

Para devolver un error en el .catch()

    function onError(id){
        console.log(`Ha sucedido un error en obtener el personaje --> ${id}`);
    }

Encadenamos las promesas. Mucho mas claro. En serie. No en paralelo.

    obtenerPersonaje(1)
        .then( (data)=> {
            console.log(`Hola, yo soy ${data.name}.`);
            return obtenerPersonaje(2)
        })
        .then( (data)=> {
            console.log(`Hola, yo soy ${data.name}.`);
            return obtenerPersonaje(3)
        })
        .then( (data)=> {
            console.log(`Hola, yo soy ${data.name}.`);
            return obtenerPersonaje(4)
        })
        .then( (data)=> {
            console.log(`Hola, yo soy ${data.name}.`);
            return obtenerPersonaje(5)
        })
        .then( (data)=> {
            console.log(`Hola, yo soy ${data.name}.`);
            return obtenerPersonaje(6)
        })
        .then( (data)=> {
            console.log(`Hola, yo soy ${data.name}.`);
            return obtenerPersonaje(7)
        })
        .then( (data)=> {
            console.log(`Hola, yo soy ${data.name}.`);
            return obtenerPersonaje(777)
        })

        .catch(onError)

____________________________________
35.PROMESAS ENCADENADAS EN PARALELO:
------------------------------------
Para hacer el llamado a múltiples promesas, nos apoyamos en un array de ids con el que luego construimos otro arreglo de Promesas, que pasaremos como parámetro a Promise.all( arregloDePromesas ), con las promesas podemos encadenar llamadas en paralelo, algo que no es posible usando callbacks.


Vamos hacer el request para obtener los datos de la API

    const API_URL = 'https://swapi.dev/api/';
    const PEOPLE_URL = 'people/:id';

    const opts = { crossDomain: true};

    function obtenerPersonaje(id){
        return new Promise(function(resolve, reject){
            const url = `${API_URL}${PEOPLE_URL.replace(':id', id)}`;
            $
            .get(url, opts, function(data){
                resolve(data);
            })
            .fail(function(){
                reject(id);
            })
        })
    }

Para devolver un error en el .catch()

    function onError(id){
        console.log(`Ha sucedido un error en obtener el personaje --> ${id}`);
    }

Vamos a guardarnos en un arrays los personajes que queremos

    let ids = [1,2,3,4,5,6,7,8];

    let promesas = ids.map(id=>obtenerPersonaje(id));

Con promise.all(), podemos obtener un arrays de promesas.

    Promise
        .all(promesas)
        .then(function(data){console.log(data)})
        .catch(onError);

_______________
36.ASYNC-AWAIT:
---------------
Async-await es la manera más simple y clara de realizar tareas asíncronas. Await detiene la ejecución del programa hasta que todas las promesas sean resueltas. Para poder utilizar esta forma, hay que colocar async antes de la definición de la función, y encerrar el llamado a Promises.all() dentro de un bloque try … catch.


Vamos hacer el request para obtener los datos de la API

    const API_URL = 'https://swapi.dev/api/';
    const PEOPLE_URL = 'people/:id';

    const opts = { crossDomain: true};

    function obtenerPersonaje(id){
        return new Promise(function(resolve, reject){
            const url = `${API_URL}${PEOPLE_URL.replace(':id', id)}`;
            $
            .get(url, opts, function(data){
                resolve(data);
            })
            .fail(function(){
                reject(id);
            })
        })
    }

Para devolver un error en el .catch()

    function onError(id){
        console.log(`Ha sucedido un error en obtener el personaje --> ${id}`);
    }

    async function obtenerPersonajes(){
        let ids = [1,2,3,4,5,6,7,8];
        let promesas = ids.map(id=>obtenerPersonaje(id))
        try {
            let data = await Promise.all(promesas)
            console.log(data)
            console.table(data)
        } catch (id) {
            onError(id)
        }
    }
    obtenerPersonajes();

___________________________________
38.DIFERENCIAS ENTRE VAR-LET-CONST:
-----------------------------------
““var”” es la manera más antigua de declarar variables. No es muy estricta en cuanto al alcance, ya que al declarar variables de esta forma, dichas variables podrán ser accedidas, e incluso modificadas, tanto dentro como fuera de los bloques internos en una función.

Con ““let”” por otra parte, el alcance se reduce al bloque (las llaves) en el cual la variable fue declarada. Fuera de este bloque la variable no existe. Una vez declarada la variable con let, no se puede volver a declarar con en ninguna otra parte de la función.

““const”” al igual que ““let”” se define en el contexto o alcance de un bloque, a diferencia de let y var, las variables definidas como constantes (const), ya no podrán ser modificadas ni declaradas nuevamente, en ninguna otra parte de la función o el contexto en el que ya existen.

La recomendación es reducir siempre al mínimo el alcance de nuestras variables, por lo que se debe usar let en lugar de var mientras sea posible.

______________________
39.VARIABLE TIPO DATE:
----------------------
Con variables de tipo Date, se pueden realizar operaciones de suma y resta similares a las que se realizan con números. El resultado que se obtiene está en milisegundos, por lo que luego hay que hacer algunas operaciones adicionales para llevarlos a días, meses o años según queramos. También aplica para Horas, Minutos, Segundos y Milisegundos.

Manejo de fechas dentro de JS

Calculo de los dias desde mi nacimiento

    function diasEntrefechas(fecha1, fecha2){
        const unDia = 1000 * 60 * 60 * 24
        const diferencia = Math.abs(fecha1 -fecha2)
        return Math.floor(diferencia / unDia)
    }

    const hoy = new Date()
    const nacimiento = new Date(1975,7,14)

    console.log(hoy)
    console.log(nacimiento)
    let diasDesdeQueNaci = diasEntrefechas(hoy,nacimiento)
    console.log(diasDesdeQueNaci)

    let edad = Math.floor(diasDesdeQueNaci / 365)
    console.log(edad)

________________________
40.FUNCIONES-RECURSIVAS:
------------------------
La recursividad es un concepto muy importante en cualquier lenguaje de programación. Una función recursiva es básicamente aquella que se llama (o se ejecuta) a sí misma de forma controlada, hasta que sucede una condición base.

    13/ 4

    13-4 = 9   1
    9-4  = 5   1
    5-4  = 1   1
    1-4  =-3   0



    function divisionEntera(dividendo, divisor){
        if(dividendo < divisor){
            return 0
        }
        return 1 + divisionEntera(dividendo - divisor, divisor)
    }

    let result = divisionEntera(13,4);
    console.log(result)

____________________________
42.ENTENDIENDO LOS CLOSURES:
----------------------------
Es un concepto muy importante en JS.
Un closure, básicamente, es una función que recuerda el estado de las variables al momento de ser invocada, y conserva este estado a través de reiteradas ejecuciones. Un aspecto fundamental de los closures es que son funciones que retornan otras funciones.

    function crearSaludo(finalDeFrase){
        return function(nombre){
            console.log(`Hola ${nombre} ${finalDeFrase}.`)

        }
    }

    const saludoArgentino = crearSaludo('che')
    const saludoMexicano = crearSaludo('guey')
    const saludoColombiano = crearSaludo('amigo')

    saludoArgentino('Sacha') // hola sacha che
    saludoMexicano('Sacha') // hola sacha guet
    saludoColombiano('Sacha') // hola sacha amigo

__________________________________
43.ESTRUCTURA DE DATOS INMUTABLES:
----------------------------------
Las estructuras de datos inmutables forman parte de los principios de la Programación Funcional y nos permiten evitar tener efectos colaterales en los datos. En otras palabras, que hayan modificaciones en las variables sin nuestro consentimiento, produciendo comportamientos inesperados en el programa.

    const sacha = {
        nombre: 'Sacha',
        apellido: 'Lifszic',
        edad: 28
    }

Como recordamos la funcion altera y modifica el objeto inicial generando un efecto de lado.

    const cumpleanos = (persona) => {
        return persona.edad++
    }
    cumpleanos(sacha);

De esta manera estamos creando un nuevo objeto y no modificamos el original

    const cumpleanosInmutable = (persona) => {
        return {
            ...persona,
            edad: persona.edad +1
        }
    }

    console.log(sacha)
    console.log(cumpleanosInmutable(sacha))
    console.log(sacha)

_______________________________________________
44.CAMBIANDO EL CONTEXTO AL LLAMAR UNA FUNCION:
-----------------------------------------------
El contexto (o alcance) de una función es por lo general, window. Así que en ciertos casos, cuando intentamos referirnos a this en alguna parte del código, es posible que tengamos un comportamiento inesperado, porque el contexto quizás no sea el que esperamos.

Existen al menos tres maneras de cambiar el contexto de una función.

- Usando el método .bind, enviamos la referencia a la función sin ejecutarla, pasando el contexto como parámetro.
- Usando el método .call, ejecutamos inmediatamente la función con el contexto indicado
- Usando el método .apply, es similar a .call pero los parámetros adicionales se pasan como un arreglo de valores


    const alfred = {
        nombre: 'Alfred',
        apellido: 'Sánchez',
        edad: 45
    }
    const jose = {
        nombre: 'Jose',
        apellido: 'Morales',
        edad: 33
    }

    function saludar(saludo = 'Hola') {
        console.log(`${saludo}, mi nombre es ${this.nombre}`) // Hola, mi nombre es undefined
    }
    saludar(alfred)

Con el metodo bind() le pegamos en contexto a windows

    const saludarAAlfred = saludar.bind(alfred)
    saludarAAlfred()
    const saludarAJose = saludar.bind(jose)
    saludarAJose()


    setTimeout(saludar.bind(alfred, 'hola men'),2000)

    setTimeout(saludar.bind(jose),3000)

    // call y apply

    saludar.call(alfred, 'Q tal men')

    saludar.apply(alfred,['Eyy men'])
